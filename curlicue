#!/bin/sh

# Curlicue - an OAuth wrapper for curl
#
# Copyright Â© 2010 Decklin Foster <decklin@red-bean.com>
# Please see README for usage information and LICENSE for license.

# Because HTTP responses from the OAuth "dance" will be URL-encoded, and
# we want to round-trip this data, we require that credentials files are
# also URL-encoded. Therefore, no decoding is done here. $1 is the name
# of another function that processes each pair (as two args).

load_cred_file() {
    foreach_query_pair parse_cred "$(cat "$1" 2>/dev/null)"
}

foreach_query_pair() {
    local IFS='&'
    for i in $2; do
        $1 "${i%%=*}" "${i#*=}"
    done
}

# This list is tiring, but we can't just let random files set any old
# variable. The ones that don't start with oauth_ are extensions from
# one provider or another.

parse_cred() {
    case "$1" in
        oauth_consumer_key) oauth_consumer_key="$2";;
        oauth_consumer_secret) oauth_consumer_secret="$2";;
        oauth_token) oauth_token="$2";;
        oauth_token_secret) oauth_token_secret="$2";;
        user_id) user_id="$2";;
        screen_name) screen_name="$2";;
        application_name) application_name="$2";;
    esac
}

quote_vals() {
    sed 's/=\(.*\)/="\1"/'
}

echo_pair() {
    echo "$1=$2"
}

join_params() {
    paste -s -d "$1" -
}

# Use curl's --data-urlencode to URL-encode one or more arguments. See
# the curl manual for a full description of the syntax of this option
# (in short: prepend a = to any arg that isn't a key=value URL param).
# Encoded args will be separated by & in the output.

encode_arg() {
    curl -s -w '%{url_effective}' --data-urlencode "$1" -G / | cut -c 3-
}

curl_encode() {
    for i; do encode_arg "$i"; done | join_params '&'
}

# The timestamp/nonce are generated in this script, so they need to be
# URL-encoded. The key/token are read in from already URL-encoded files,
# so they should *not* be encoded again. This, along with the sort,
# means we cannot factor out the call to curl_encode.

mk_params() {
    for i in \
        oauth_version="$(curl_encode "=1.0")" \
        oauth_signature_method="$(curl_encode "=HMAC-SHA1")" \
        oauth_timestamp="$(curl_encode "=$oauth_timestamp")" \
        oauth_nonce="$(curl_encode "=$oauth_nonce")" \
        oauth_consumer_key="$oauth_consumer_key" \
        ${oauth_token:+oauth_token="$oauth_token"} \
        $(foreach_query_pair echo_pair "$extra_params") \
        $(foreach_query_pair echo_pair "$1")
    do
        echo "$i"
    done | sort
}

# This is bad; it leaks the secret on the command line. The right thing
# would be to use -passin, but it doesn't seem to affect -hmac.

hmac_sha1() {
    printf '%s' "$2" | openssl dgst -sha1 -hmac "$1" -binary | openssl base64
}

# These are the two possible modes we can run in; get a new set of credentials
# or make a request.

setup_credentials() {
    test -n "$consumer_key" || read -p 'Consumer Key: ' consumer_key
    test -n "$consumer_secret" || read -p 'Consumer Secret: ' consumer_secret
    test -n "$request_token_url" || read -p 'Request Token URL: ' request_token_url
    test -n "$authorize_url" || read -p 'Authorize URL: ' authorize_url
    test -n "$access_token_url" || read -p 'Access Token URL: ' request_token_url

    consumer_tmp=$(mktemp -t curlicue_consumer.XXXXXX)
    request_token_tmp=$(mktemp -t curlicue_request_token.XXXXXX)
    access_token_tmp=$(mktemp -t curlicue_access_token.XXXXXX)

    # TODO: we should be able to do the remaining calls in-process now
    curl_encode "oauth_consumer_key=$consumer_key" "oauth_consumer_secret=$consumer_secret" > "$consumer_tmp"
    load_cred_file "$consumer_tmp"
    curlicue -f "$consumer_tmp" -p 'oauth_callback=oob' -- -s -X POST "$request_token_url" > "$request_token_tmp"
    load_cred_file "$request_token_tmp"
    echo "OK, load this URL: $(eval "echo \"$authorize_url\"")"
    read -p 'PIN: ' pin
    curlicue -f "$consumer_tmp" -f "$request_token_tmp" ${pin:+-p "oauth_verifier=$pin"} -- -s -X POST "$access_token_url" > "$access_token_tmp"
    paste -d '&' "$consumer_tmp" "$access_token_tmp" > "$new_cred_file"
    echo "Wrote $new_cred_file"
    rm -f "$consumer_tmp" "$request_token_tmp" "$access_token_tmp"
}

oauth_curl() {
    method=GET
    oauth_timestamp="$(date +%s)"
    oauth_nonce="$(openssl rand -base64 12)"

    # The remaining args in $@ go directly to curl. Fools that we are, we
    # attempt to parse them here. Only one URL is supported.

    for i; do
        case "$prev" in
            -d|--data) test -z "$data_is_not_params" && url_params="$i";;
            -X|--request) method="$i";;
        esac
        case "$i" in
            -d|--data) method=POST;;
            http*\?*) url="${i%%\?*}"; url_params="${i#*\?}";;
            http*) url="$i";;
        esac
        prev="$i"
    done

    if test -z "$loaded"; then
        cropped_url="${url#*://}"
        host="${cropped_url%%/*}"
        load_cred_file "$HOME/.curlicue/$host"
    fi

    if test -z "$oauth_consumer_key"; then
        echo "Couldn't load a consumer key! Exiting." 1>&2
        exit 1
    fi

    # This is where the magic happens.
    params="$(mk_params "$url_params" | join_params '&')"
    base_string="$(curl_encode "=$method" "=$url" "=$params")"
    signing_key="$oauth_consumer_secret&$oauth_token_secret"
    oauth_signature="$(hmac_sha1 "$signing_key" "$base_string")"
    sig_params="$(curl_encode "oauth_signature=$oauth_signature")"
    auth_header="$(mk_params "$sig_params" | quote_vals | join_params ',')"

    if test -n "$verbose"; then
        echo "Base string: $base_string" 1>&2
        echo "Authorization: OAuth $auth_header" 1>&2
    fi

    curl -H "Authorization: OAuth $auth_header" "$@"
}

while getopts 'F:K:S:R:A:T:f:Pp:vu' opt; do
    case "$opt" in
        # Options for first-time setup
        F) new_cred_file="$OPTARG";;
        K) consumer_key="$OPTARG";;
        S) consumer_secret="$OPTARG";;
        R) request_token_url="$OPTARG";;
        A) authorize_url="$OPTARG";;
        T) access_token_url="$OPTARG";;
        # Options for normal operation
        f) load_cred_file "$OPTARG"; loaded=1;;
        P) data_is_not_params=1;;
        p) extra_params="$OPTARG";;
        v) verbose=1;;
        *) echo "Unknown option: $opt"; exit 2;;
    esac
done; shift $(($OPTIND-1))

if test -n "$new_cred_file"; then
    setup_credentials
else
    oauth_curl "$@"
fi
